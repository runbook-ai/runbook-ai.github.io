import { loadSettings, getAllowedUsers } from './settings.js';

const EXTENSION_ID = 'kjbhngehjkiiecaflccjenmoccielojj';
import { logMessage, logSystem, showProcessing, hideProcessing } from './ui.js';
import { sendDiscordMessage, triggerTyping, openDMChannel, addReaction } from './discord.js';

// â”€â”€ Task queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Each entry: { msg, channelId, prompt, config, s }
// Tasks are processed one at a time because the extension can only handle
// one runHeadlessTask at a time.
const taskQueue = [];
let queueRunning = false;

/**
 * Add a task to the queue and start processing if idle.
 * Immediately adds a â³ reaction so the user knows their message was received.
 */
function enqueueTask(msg, channelId, prompt, config, s) {
  taskQueue.push({ msg, channelId, prompt, config, s });
  // Ack: message received and queued
  addReaction(channelId, msg.id, '%F0%9F%91%8D', s.botToken); // ðŸ‘
  if (!queueRunning) processQueue();
}

/**
 * Drain the queue serially. For each task:
 *   1. Add ðŸ‘€ reaction â€” signals processing has started
 *   2. Run the task via the extension
 *   3. Continue to next task
 */
async function processQueue() {
  if (queueRunning) return;
  queueRunning = true;
  while (taskQueue.length > 0) {
    const { msg, channelId, prompt, config, s } = taskQueue.shift();
    showProcessing(channelId);
    triggerTyping(channelId, s.botToken);
    try {
      await runViaExtension(msg, channelId, prompt, config, s);
    } finally {
      hideProcessing();
    }
  }
  queueRunning = false;
}

// â”€â”€ Message handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Handle an incoming Discord MESSAGE_CREATE event.
 * All responses are generated by the Runbook AI extension via runHeadlessTask.
 *
 * @param {object} msg       - Discord message object from the Gateway
 * @param {string} botUserId - The bot's own user ID (to skip self-messages)
 */
export async function handleMessageCreate(msg, botUserId) {
  // Only respond to direct messages.
  if (msg.guild_id) return;
  if (msg.author?.id === botUserId) return;
  if (msg.author?.bot) return;

  // Allowlist check - ignore messages from unlisted users.
  const allowedUsers = getAllowedUsers();
  if (!allowedUsers.has(msg.author?.username?.toLowerCase())) return;

  // Empty content means MESSAGE_CONTENT intent is not enabled.
  if (!msg.content?.trim()) {
    logSystem(
      'Received a message with empty content. ' +
      'Enable the MESSAGE_CONTENT privileged intent in your Discord application settings ' +
      '(discord.com/developers ? Your App ? Bot ? Privileged Gateway Intents).',
      'error-msg'
    );
    return;
  }

  logMessage(msg, 'incoming');

  const s = loadSettings();

  // Open (or fetch) the DM channel via REST so we get an ID that works for
  // REST API calls. The channel_id from the Gateway event sometimes causes
  // 403 40333 if the DM channel hasn't been registered with the REST session.
  let channelId = msg.channel_id;
  try {
    channelId = await openDMChannel(msg.author.id, s.botToken);
    console.log('[dm] openDMChannel resolved to', channelId, '(gateway was', msg.channel_id, ')');
  } catch (e) {
    console.warn('[dm] openDMChannel failed:', e.message, '- falling back to gateway channel_id');
    logSystem(`Could not open DM channel: ${e.message}`, 'error-msg');
  }

  // !help â€” reply immediately, no queue needed
  if (/^!help\s*$/i.test(msg.content)) {
    const help =
      'Send me a message and I\'ll run it as a task.\n' +
      '`!run <runbook>` - launch a saved runbook\n' +
      '`!help` - show this message';
    await sendDiscordMessage(channelId, help, s.botToken, msg.id);
    logMessage({ channel_id: channelId, content: help }, 'outgoing');
    return;
  }

  // !run <runbook-name> [extra prompt text]
  const runMatch = msg.content.match(/^!run\s+(\S+)(.*)?$/i);
  if (runMatch) {
    await handleRunCommand(msg, channelId, runMatch[1].trim(), (runMatch[2] ?? '').trim(), s);
    return;
  }

  // Free-form message â€” enqueue for the extension to handle
  enqueueTask(msg, channelId, msg.content, {}, s);
}

/**
 * Handle the `!run <runbook-name>` command.
 * Fetches the runbook files then enqueues the task.
 * Errors during fetch are reported immediately as a reply.
 */
async function handleRunCommand(msg, channelId, runbookName, extraPrompt, s) {
  try {
    const [mdRes, jsonRes] = await Promise.all([
      fetch(`/runbooks/${runbookName}.md`),
      fetch(`/runbooks/${runbookName}.json`),
    ]);

    if (!mdRes.ok) {
      throw new Error(`Unknown runbook "${runbookName}". Try: craigslist-car-listings`);
    }

    const prompt = (extraPrompt ? `${extraPrompt}\n\n` : '') + await mdRes.text();
    const config = jsonRes.ok ? JSON.parse(await jsonRes.text()) : {};
    enqueueTask(msg, channelId, prompt, config, s);
  } catch (err) {
    logSystem(err.message, 'error-msg');
    try { await sendDiscordMessage(channelId, `Error: ${err.message}`, s.botToken, msg.id); } catch {}
  }
}

/**
 * Send a prompt + config to the Runbook AI extension via chrome.runtime.sendMessage,
 * mirroring the startRunbook() pattern from the root index.html.
 * Notifies the Discord channel with the outcome.
 * Called exclusively from processQueue â€” showProcessing/hideProcessing are
 * managed by the caller.
 */
async function runViaExtension(msg, channelId, prompt, config, s) {
  const replyToId = msg.id;

  // Tag errors that are caused by the extension not being present/responding
  // so we can show the install hint only for those.
  class ExtensionError extends Error {}

  try {
    if (typeof chrome === 'undefined' || !chrome.runtime) {
      throw new ExtensionError('Runbook AI extension is not available on this page');
    }

    const openResp = await chrome.runtime.sendMessage(EXTENSION_ID, { action: 'openSidePanel' });
    console.log('[ext] openSidePanel response:', openResp);
    if (openResp?.error) throw new ExtensionError(openResp.message || openResp.error);

    await new Promise(r => setTimeout(r, 500));

    const configResp = await chrome.runtime.sendMessage(EXTENSION_ID, {
      action: 'setRemoteConfig',
      args:   {
        config: {
          ...config,
          ...(s.freeApiKey ? {
            llmBaseUrl: 'https://llm.runbookai.net/v1',
            llmApiKey:  'free',
          } : {}),
          returnTaskState: true,
        },
      },
    });
    console.log('[ext] setRemoteConfig response:', configResp);
    if (configResp?.error) throw new ExtensionError(configResp.message || configResp.error);

    const taskResp = await chrome.runtime.sendMessage(EXTENSION_ID, {
      action: 'runHeadlessTask',
      args:   { prompt },
    });
    console.log('[ext] runHeadlessTask response:', taskResp);

    if (taskResp?.error) {
      throw new Error(taskResp.message || taskResp.error);
    }

    // Switch back to the bot tab so it stays active for the next task.
    // Match on origin+pathname prefix so trailing slashes / index.html variants all resolve.
    const botUrl = window.location.origin + window.location.pathname;
    const botTab = taskResp?.taskState?.tabs?.find(
      t => t.url && (t.url === botUrl || t.url.startsWith(botUrl.replace(/\/[^/]*$/, '/')))
    );
    if (botTab?.tabId != null) {
      chrome.runtime.sendMessage(EXTENSION_ID, {
        action: 'switchToTab',
        args:   { tabId: botTab.tabId },
      }).catch(() => {});
    }

    const reply = taskResp?.taskResult?.result || 'Task completed with no result.';
    await sendDiscordMessage(channelId, reply, s.botToken, replyToId);
    logMessage({ channel_id: channelId, content: reply }, 'outgoing');

  } catch (err) {
    console.error('[ext] runViaExtension failed:', err);
    const errText = err?.message ?? String(err);
    const notice = err instanceof ExtensionError
      ? `Extension error: ${errText}\n\nMake sure the Runbook AI extension side panel is opened.`
      : `Error: ${errText}`;
    await sendDiscordMessage(channelId, notice, s.botToken, replyToId).catch(() => {});
    logMessage({ channel_id: channelId, content: notice }, 'outgoing');
  }
}
